/*
 * ZIQNI Webhook Services
 * Webhook subscriber services intended use is to assist in the creation of a subscriber service.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: sales@ziqni.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.ziqni.webhook.model;

import java.util.Objects;
import java.util.Arrays;
import java.util.Map;
import java.util.HashMap;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonSubTypes;
import com.fasterxml.jackson.annotation.JsonTypeInfo;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import com.ziqni.webhook.model.AchievementCreated;
import com.ziqni.webhook.model.AchievementRewardClaimed;
import com.ziqni.webhook.model.AchievementRewardCreated;
import com.ziqni.webhook.model.AchievementRewardIssued;
import com.ziqni.webhook.model.AchievementTriggered;
import com.ziqni.webhook.model.CompetitionCancelled;
import com.ziqni.webhook.model.CompetitionCreated;
import com.ziqni.webhook.model.CompetitionFinished;
import com.ziqni.webhook.model.CompetitionRewardIssued;
import com.ziqni.webhook.model.CompetitionStarted;
import com.ziqni.webhook.model.ContestCancelled;
import com.ziqni.webhook.model.ContestCreated;
import com.ziqni.webhook.model.ContestFinalised;
import com.ziqni.webhook.model.ContestFinished;
import com.ziqni.webhook.model.ContestRewardClaimed;
import com.ziqni.webhook.model.ContestRewardCreated;
import com.ziqni.webhook.model.ContestRewardIssued;
import com.ziqni.webhook.model.ContestStarted;
import com.ziqni.webhook.model.NewMember;
import com.ziqni.webhook.model.NewProduct;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;

import com.fasterxml.jackson.core.type.TypeReference;

import java.io.IOException;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;

import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.JsonToken;
import com.fasterxml.jackson.databind.DeserializationContext;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.MapperFeature;
import com.fasterxml.jackson.databind.SerializerProvider;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import com.fasterxml.jackson.databind.deser.std.StdDeserializer;
import com.fasterxml.jackson.databind.ser.std.StdSerializer;
import com.ziqni.webhook.JSON;

@javax.annotation.processing.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
@JsonDeserialize(using = WebhookRequestBody.WebhookRequestBodyDeserializer.class)
@JsonSerialize(using = WebhookRequestBody.WebhookRequestBodySerializer.class)
public class WebhookRequestBody extends AbstractOpenApiSchema {
    private static final Logger log = Logger.getLogger(WebhookRequestBody.class.getName());

    public static class WebhookRequestBodySerializer extends StdSerializer<WebhookRequestBody> {
        public WebhookRequestBodySerializer(Class<WebhookRequestBody> t) {
            super(t);
        }

        public WebhookRequestBodySerializer() {
            this(null);
        }

        @Override
        public void serialize(WebhookRequestBody value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonProcessingException {
            jgen.writeObject(value.getActualInstance());
        }
    }

    public static class WebhookRequestBodyDeserializer extends StdDeserializer<WebhookRequestBody> {
        public WebhookRequestBodyDeserializer() {
            this(WebhookRequestBody.class);
        }

        public WebhookRequestBodyDeserializer(Class<?> vc) {
            super(vc);
        }

        @Override
        public WebhookRequestBody deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException {
            JsonNode tree = jp.readValueAsTree();
            Object deserialized = null;
            boolean typeCoercion = ctxt.isEnabled(MapperFeature.ALLOW_COERCION_OF_SCALARS);
            int match = 0;
            JsonToken token = tree.traverse(jp.getCodec()).nextToken();
            // deserialize AchievementCreated
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (AchievementCreated.class.equals(Integer.class) || AchievementCreated.class.equals(Long.class) || AchievementCreated.class.equals(Float.class) || AchievementCreated.class.equals(Double.class) || AchievementCreated.class.equals(Boolean.class) || AchievementCreated.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((AchievementCreated.class.equals(Integer.class) || AchievementCreated.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((AchievementCreated.class.equals(Float.class) || AchievementCreated.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (AchievementCreated.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (AchievementCreated.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(AchievementCreated.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'AchievementCreated'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'AchievementCreated'", e);
            }

            // deserialize AchievementRewardClaimed
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (AchievementRewardClaimed.class.equals(Integer.class) || AchievementRewardClaimed.class.equals(Long.class) || AchievementRewardClaimed.class.equals(Float.class) || AchievementRewardClaimed.class.equals(Double.class) || AchievementRewardClaimed.class.equals(Boolean.class) || AchievementRewardClaimed.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((AchievementRewardClaimed.class.equals(Integer.class) || AchievementRewardClaimed.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((AchievementRewardClaimed.class.equals(Float.class) || AchievementRewardClaimed.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (AchievementRewardClaimed.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (AchievementRewardClaimed.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(AchievementRewardClaimed.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'AchievementRewardClaimed'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'AchievementRewardClaimed'", e);
            }

            // deserialize AchievementRewardCreated
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (AchievementRewardCreated.class.equals(Integer.class) || AchievementRewardCreated.class.equals(Long.class) || AchievementRewardCreated.class.equals(Float.class) || AchievementRewardCreated.class.equals(Double.class) || AchievementRewardCreated.class.equals(Boolean.class) || AchievementRewardCreated.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((AchievementRewardCreated.class.equals(Integer.class) || AchievementRewardCreated.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((AchievementRewardCreated.class.equals(Float.class) || AchievementRewardCreated.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (AchievementRewardCreated.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (AchievementRewardCreated.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(AchievementRewardCreated.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'AchievementRewardCreated'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'AchievementRewardCreated'", e);
            }

            // deserialize AchievementRewardIssued
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (AchievementRewardIssued.class.equals(Integer.class) || AchievementRewardIssued.class.equals(Long.class) || AchievementRewardIssued.class.equals(Float.class) || AchievementRewardIssued.class.equals(Double.class) || AchievementRewardIssued.class.equals(Boolean.class) || AchievementRewardIssued.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((AchievementRewardIssued.class.equals(Integer.class) || AchievementRewardIssued.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((AchievementRewardIssued.class.equals(Float.class) || AchievementRewardIssued.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (AchievementRewardIssued.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (AchievementRewardIssued.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(AchievementRewardIssued.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'AchievementRewardIssued'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'AchievementRewardIssued'", e);
            }

            // deserialize AchievementTriggered
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (AchievementTriggered.class.equals(Integer.class) || AchievementTriggered.class.equals(Long.class) || AchievementTriggered.class.equals(Float.class) || AchievementTriggered.class.equals(Double.class) || AchievementTriggered.class.equals(Boolean.class) || AchievementTriggered.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((AchievementTriggered.class.equals(Integer.class) || AchievementTriggered.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((AchievementTriggered.class.equals(Float.class) || AchievementTriggered.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (AchievementTriggered.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (AchievementTriggered.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(AchievementTriggered.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'AchievementTriggered'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'AchievementTriggered'", e);
            }

            // deserialize CompetitionCancelled
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (CompetitionCancelled.class.equals(Integer.class) || CompetitionCancelled.class.equals(Long.class) || CompetitionCancelled.class.equals(Float.class) || CompetitionCancelled.class.equals(Double.class) || CompetitionCancelled.class.equals(Boolean.class) || CompetitionCancelled.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((CompetitionCancelled.class.equals(Integer.class) || CompetitionCancelled.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((CompetitionCancelled.class.equals(Float.class) || CompetitionCancelled.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (CompetitionCancelled.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (CompetitionCancelled.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(CompetitionCancelled.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'CompetitionCancelled'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'CompetitionCancelled'", e);
            }

            // deserialize CompetitionCreated
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (CompetitionCreated.class.equals(Integer.class) || CompetitionCreated.class.equals(Long.class) || CompetitionCreated.class.equals(Float.class) || CompetitionCreated.class.equals(Double.class) || CompetitionCreated.class.equals(Boolean.class) || CompetitionCreated.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((CompetitionCreated.class.equals(Integer.class) || CompetitionCreated.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((CompetitionCreated.class.equals(Float.class) || CompetitionCreated.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (CompetitionCreated.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (CompetitionCreated.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(CompetitionCreated.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'CompetitionCreated'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'CompetitionCreated'", e);
            }

            // deserialize CompetitionFinished
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (CompetitionFinished.class.equals(Integer.class) || CompetitionFinished.class.equals(Long.class) || CompetitionFinished.class.equals(Float.class) || CompetitionFinished.class.equals(Double.class) || CompetitionFinished.class.equals(Boolean.class) || CompetitionFinished.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((CompetitionFinished.class.equals(Integer.class) || CompetitionFinished.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((CompetitionFinished.class.equals(Float.class) || CompetitionFinished.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (CompetitionFinished.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (CompetitionFinished.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(CompetitionFinished.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'CompetitionFinished'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'CompetitionFinished'", e);
            }

            // deserialize CompetitionRewardIssued
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (CompetitionRewardIssued.class.equals(Integer.class) || CompetitionRewardIssued.class.equals(Long.class) || CompetitionRewardIssued.class.equals(Float.class) || CompetitionRewardIssued.class.equals(Double.class) || CompetitionRewardIssued.class.equals(Boolean.class) || CompetitionRewardIssued.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((CompetitionRewardIssued.class.equals(Integer.class) || CompetitionRewardIssued.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((CompetitionRewardIssued.class.equals(Float.class) || CompetitionRewardIssued.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (CompetitionRewardIssued.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (CompetitionRewardIssued.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(CompetitionRewardIssued.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'CompetitionRewardIssued'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'CompetitionRewardIssued'", e);
            }

            // deserialize CompetitionStarted
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (CompetitionStarted.class.equals(Integer.class) || CompetitionStarted.class.equals(Long.class) || CompetitionStarted.class.equals(Float.class) || CompetitionStarted.class.equals(Double.class) || CompetitionStarted.class.equals(Boolean.class) || CompetitionStarted.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((CompetitionStarted.class.equals(Integer.class) || CompetitionStarted.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((CompetitionStarted.class.equals(Float.class) || CompetitionStarted.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (CompetitionStarted.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (CompetitionStarted.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(CompetitionStarted.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'CompetitionStarted'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'CompetitionStarted'", e);
            }

            // deserialize ContestCancelled
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (ContestCancelled.class.equals(Integer.class) || ContestCancelled.class.equals(Long.class) || ContestCancelled.class.equals(Float.class) || ContestCancelled.class.equals(Double.class) || ContestCancelled.class.equals(Boolean.class) || ContestCancelled.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((ContestCancelled.class.equals(Integer.class) || ContestCancelled.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((ContestCancelled.class.equals(Float.class) || ContestCancelled.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (ContestCancelled.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (ContestCancelled.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(ContestCancelled.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'ContestCancelled'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'ContestCancelled'", e);
            }

            // deserialize ContestCreated
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (ContestCreated.class.equals(Integer.class) || ContestCreated.class.equals(Long.class) || ContestCreated.class.equals(Float.class) || ContestCreated.class.equals(Double.class) || ContestCreated.class.equals(Boolean.class) || ContestCreated.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((ContestCreated.class.equals(Integer.class) || ContestCreated.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((ContestCreated.class.equals(Float.class) || ContestCreated.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (ContestCreated.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (ContestCreated.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(ContestCreated.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'ContestCreated'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'ContestCreated'", e);
            }

            // deserialize ContestFinalised
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (ContestFinalised.class.equals(Integer.class) || ContestFinalised.class.equals(Long.class) || ContestFinalised.class.equals(Float.class) || ContestFinalised.class.equals(Double.class) || ContestFinalised.class.equals(Boolean.class) || ContestFinalised.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((ContestFinalised.class.equals(Integer.class) || ContestFinalised.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((ContestFinalised.class.equals(Float.class) || ContestFinalised.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (ContestFinalised.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (ContestFinalised.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(ContestFinalised.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'ContestFinalised'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'ContestFinalised'", e);
            }

            // deserialize ContestFinished
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (ContestFinished.class.equals(Integer.class) || ContestFinished.class.equals(Long.class) || ContestFinished.class.equals(Float.class) || ContestFinished.class.equals(Double.class) || ContestFinished.class.equals(Boolean.class) || ContestFinished.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((ContestFinished.class.equals(Integer.class) || ContestFinished.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((ContestFinished.class.equals(Float.class) || ContestFinished.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (ContestFinished.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (ContestFinished.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(ContestFinished.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'ContestFinished'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'ContestFinished'", e);
            }

            // deserialize ContestRewardClaimed
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (ContestRewardClaimed.class.equals(Integer.class) || ContestRewardClaimed.class.equals(Long.class) || ContestRewardClaimed.class.equals(Float.class) || ContestRewardClaimed.class.equals(Double.class) || ContestRewardClaimed.class.equals(Boolean.class) || ContestRewardClaimed.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((ContestRewardClaimed.class.equals(Integer.class) || ContestRewardClaimed.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((ContestRewardClaimed.class.equals(Float.class) || ContestRewardClaimed.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (ContestRewardClaimed.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (ContestRewardClaimed.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(ContestRewardClaimed.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'ContestRewardClaimed'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'ContestRewardClaimed'", e);
            }

            // deserialize ContestRewardCreated
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (ContestRewardCreated.class.equals(Integer.class) || ContestRewardCreated.class.equals(Long.class) || ContestRewardCreated.class.equals(Float.class) || ContestRewardCreated.class.equals(Double.class) || ContestRewardCreated.class.equals(Boolean.class) || ContestRewardCreated.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((ContestRewardCreated.class.equals(Integer.class) || ContestRewardCreated.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((ContestRewardCreated.class.equals(Float.class) || ContestRewardCreated.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (ContestRewardCreated.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (ContestRewardCreated.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(ContestRewardCreated.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'ContestRewardCreated'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'ContestRewardCreated'", e);
            }

            // deserialize ContestRewardIssued
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (ContestRewardIssued.class.equals(Integer.class) || ContestRewardIssued.class.equals(Long.class) || ContestRewardIssued.class.equals(Float.class) || ContestRewardIssued.class.equals(Double.class) || ContestRewardIssued.class.equals(Boolean.class) || ContestRewardIssued.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((ContestRewardIssued.class.equals(Integer.class) || ContestRewardIssued.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((ContestRewardIssued.class.equals(Float.class) || ContestRewardIssued.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (ContestRewardIssued.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (ContestRewardIssued.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(ContestRewardIssued.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'ContestRewardIssued'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'ContestRewardIssued'", e);
            }

            // deserialize ContestStarted
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (ContestStarted.class.equals(Integer.class) || ContestStarted.class.equals(Long.class) || ContestStarted.class.equals(Float.class) || ContestStarted.class.equals(Double.class) || ContestStarted.class.equals(Boolean.class) || ContestStarted.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((ContestStarted.class.equals(Integer.class) || ContestStarted.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((ContestStarted.class.equals(Float.class) || ContestStarted.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (ContestStarted.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (ContestStarted.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(ContestStarted.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'ContestStarted'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'ContestStarted'", e);
            }

            // deserialize NewMember
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (NewMember.class.equals(Integer.class) || NewMember.class.equals(Long.class) || NewMember.class.equals(Float.class) || NewMember.class.equals(Double.class) || NewMember.class.equals(Boolean.class) || NewMember.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((NewMember.class.equals(Integer.class) || NewMember.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((NewMember.class.equals(Float.class) || NewMember.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (NewMember.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (NewMember.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(NewMember.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'NewMember'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'NewMember'", e);
            }

            // deserialize NewProduct
            try {
                boolean attemptParsing = true;
                // ensure that we respect type coercion as set on the client ObjectMapper
                if (NewProduct.class.equals(Integer.class) || NewProduct.class.equals(Long.class) || NewProduct.class.equals(Float.class) || NewProduct.class.equals(Double.class) || NewProduct.class.equals(Boolean.class) || NewProduct.class.equals(String.class)) {
                    attemptParsing = typeCoercion;
                    if (!attemptParsing) {
                        attemptParsing |= ((NewProduct.class.equals(Integer.class) || NewProduct.class.equals(Long.class)) && token == JsonToken.VALUE_NUMBER_INT);
                        attemptParsing |= ((NewProduct.class.equals(Float.class) || NewProduct.class.equals(Double.class)) && token == JsonToken.VALUE_NUMBER_FLOAT);
                        attemptParsing |= (NewProduct.class.equals(Boolean.class) && (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE));
                        attemptParsing |= (NewProduct.class.equals(String.class) && token == JsonToken.VALUE_STRING);
                    }
                }
                if (attemptParsing) {
                    deserialized = tree.traverse(jp.getCodec()).readValueAs(NewProduct.class);
                    // TODO: there is no validation against JSON schema constraints
                    // (min, max, enum, pattern...), this does not perform a strict JSON
                    // validation, which means the 'match' count may be higher than it should be.
                    match++;
                    log.log(Level.FINER, "Input data matches schema 'NewProduct'");
                }
            } catch (Exception e) {
                // deserialization failed, continue
                log.log(Level.FINER, "Input data does not match schema 'NewProduct'", e);
            }

            if (match == 1) {
                WebhookRequestBody ret = new WebhookRequestBody();
                ret.setActualInstance(deserialized);
                return ret;
            }
            throw new IOException(String.format("Failed deserialization for WebhookRequestBody: %d classes match result, expected 1", match));
        }

        /**
         * Handle deserialization of the 'null' value.
         */
        @Override
        public WebhookRequestBody getNullValue(DeserializationContext ctxt) throws JsonMappingException {
            throw new JsonMappingException(ctxt.getParser(), "WebhookRequestBody cannot be null");
        }
    }

    // store a list of schema names defined in oneOf
    public static final Map<String, Class<?>> schemas = new HashMap<>();

    public WebhookRequestBody() {
        super("oneOf", Boolean.FALSE);
    }

    public WebhookRequestBody(AchievementCreated o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public WebhookRequestBody(AchievementRewardClaimed o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public WebhookRequestBody(AchievementRewardCreated o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public WebhookRequestBody(AchievementRewardIssued o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public WebhookRequestBody(AchievementTriggered o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public WebhookRequestBody(CompetitionCancelled o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public WebhookRequestBody(CompetitionCreated o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public WebhookRequestBody(CompetitionFinished o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public WebhookRequestBody(CompetitionRewardIssued o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public WebhookRequestBody(CompetitionStarted o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public WebhookRequestBody(ContestCancelled o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public WebhookRequestBody(ContestCreated o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public WebhookRequestBody(ContestFinalised o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public WebhookRequestBody(ContestFinished o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public WebhookRequestBody(ContestRewardClaimed o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public WebhookRequestBody(ContestRewardCreated o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public WebhookRequestBody(ContestRewardIssued o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public WebhookRequestBody(ContestStarted o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public WebhookRequestBody(NewMember o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public WebhookRequestBody(NewProduct o) {
        super("oneOf", Boolean.FALSE);
        setActualInstance(o);
    }

    static {
        schemas.put("AchievementCreated", AchievementCreated.class);
        schemas.put("AchievementRewardClaimed", AchievementRewardClaimed.class);
        schemas.put("AchievementRewardCreated", AchievementRewardCreated.class);
        schemas.put("AchievementRewardIssued", AchievementRewardIssued.class);
        schemas.put("AchievementTriggered", AchievementTriggered.class);
        schemas.put("CompetitionCancelled", CompetitionCancelled.class);
        schemas.put("CompetitionCreated", CompetitionCreated.class);
        schemas.put("CompetitionFinished", CompetitionFinished.class);
        schemas.put("CompetitionRewardIssued", CompetitionRewardIssued.class);
        schemas.put("CompetitionStarted", CompetitionStarted.class);
        schemas.put("ContestCancelled", ContestCancelled.class);
        schemas.put("ContestCreated", ContestCreated.class);
        schemas.put("ContestFinalised", ContestFinalised.class);
        schemas.put("ContestFinished", ContestFinished.class);
        schemas.put("ContestRewardClaimed", ContestRewardClaimed.class);
        schemas.put("ContestRewardCreated", ContestRewardCreated.class);
        schemas.put("ContestRewardIssued", ContestRewardIssued.class);
        schemas.put("ContestStarted", ContestStarted.class);
        schemas.put("NewMember", NewMember.class);
        schemas.put("NewProduct", NewProduct.class);
        JSON.registerDescendants(WebhookRequestBody.class, Collections.unmodifiableMap(schemas));
        // Initialize and register the discriminator mappings.
        Map<String, Class<?>> mappings = new HashMap<String, Class<?>>();
        mappings.put("AchievementCreated", AchievementCreated.class);
        mappings.put("AchievementRewardClaimed", AchievementRewardClaimed.class);
        mappings.put("AchievementRewardCreated", AchievementRewardCreated.class);
        mappings.put("AchievementRewardIssued", AchievementRewardIssued.class);
        mappings.put("AchievementTriggered", AchievementTriggered.class);
        mappings.put("CompetitionCancelled", CompetitionCancelled.class);
        mappings.put("CompetitionCreated", CompetitionCreated.class);
        mappings.put("CompetitionFinished", CompetitionFinished.class);
        mappings.put("CompetitionRewardIssued", CompetitionRewardIssued.class);
        mappings.put("CompetitionStarted", CompetitionStarted.class);
        mappings.put("ContestCancelled", ContestCancelled.class);
        mappings.put("ContestCreated", ContestCreated.class);
        mappings.put("ContestFinalised", ContestFinalised.class);
        mappings.put("ContestFinished", ContestFinished.class);
        mappings.put("ContestRewardClaimed", ContestRewardClaimed.class);
        mappings.put("ContestRewardCreated", ContestRewardCreated.class);
        mappings.put("ContestRewardIssued", ContestRewardIssued.class);
        mappings.put("ContestStarted", ContestStarted.class);
        mappings.put("NewMember", NewMember.class);
        mappings.put("NewProduct", NewProduct.class);
        mappings.put("WebhookRequestBody", WebhookRequestBody.class);
        JSON.registerDiscriminator(WebhookRequestBody.class, "objectType", mappings);
    }

    @Override
    public Map<String, Class<?>> getSchemas() {
        return WebhookRequestBody.schemas;
    }

    /**
     * Set the instance that matches the oneOf child schema, check
     * the instance parameter is valid against the oneOf child schemas:
     * AchievementCreated, AchievementRewardClaimed, AchievementRewardCreated, AchievementRewardIssued, AchievementTriggered, CompetitionCancelled, CompetitionCreated, CompetitionFinished, CompetitionRewardIssued, CompetitionStarted, ContestCancelled, ContestCreated, ContestFinalised, ContestFinished, ContestRewardClaimed, ContestRewardCreated, ContestRewardIssued, ContestStarted, NewMember, NewProduct
     *
     * It could be an instance of the 'oneOf' schemas.
     * The oneOf child schemas may themselves be a composed schema (allOf, anyOf, oneOf).
     */
    @Override
    public void setActualInstance(Object instance) {
        if (JSON.isInstanceOf(AchievementCreated.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(AchievementRewardClaimed.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(AchievementRewardCreated.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(AchievementRewardIssued.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(AchievementTriggered.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(CompetitionCancelled.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(CompetitionCreated.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(CompetitionFinished.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(CompetitionRewardIssued.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(CompetitionStarted.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(ContestCancelled.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(ContestCreated.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(ContestFinalised.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(ContestFinished.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(ContestRewardClaimed.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(ContestRewardCreated.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(ContestRewardIssued.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(ContestStarted.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(NewMember.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(NewProduct.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        throw new RuntimeException("Invalid instance type. Must be AchievementCreated, AchievementRewardClaimed, AchievementRewardCreated, AchievementRewardIssued, AchievementTriggered, CompetitionCancelled, CompetitionCreated, CompetitionFinished, CompetitionRewardIssued, CompetitionStarted, ContestCancelled, ContestCreated, ContestFinalised, ContestFinished, ContestRewardClaimed, ContestRewardCreated, ContestRewardIssued, ContestStarted, NewMember, NewProduct");
    }

    /**
     * Get the actual instance, which can be the following:
     * AchievementCreated, AchievementRewardClaimed, AchievementRewardCreated, AchievementRewardIssued, AchievementTriggered, CompetitionCancelled, CompetitionCreated, CompetitionFinished, CompetitionRewardIssued, CompetitionStarted, ContestCancelled, ContestCreated, ContestFinalised, ContestFinished, ContestRewardClaimed, ContestRewardCreated, ContestRewardIssued, ContestStarted, NewMember, NewProduct
     *
     * @return The actual instance (AchievementCreated, AchievementRewardClaimed, AchievementRewardCreated, AchievementRewardIssued, AchievementTriggered, CompetitionCancelled, CompetitionCreated, CompetitionFinished, CompetitionRewardIssued, CompetitionStarted, ContestCancelled, ContestCreated, ContestFinalised, ContestFinished, ContestRewardClaimed, ContestRewardCreated, ContestRewardIssued, ContestStarted, NewMember, NewProduct)
     */
    @Override
    public Object getActualInstance() {
        return super.getActualInstance();
    }

    /**
     * Get the actual instance of `AchievementCreated`. If the actual instanct is not `AchievementCreated`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `AchievementCreated`
     * @throws ClassCastException if the instance is not `AchievementCreated`
     */
    public AchievementCreated getAchievementCreated() throws ClassCastException {
        return (AchievementCreated)super.getActualInstance();
    }

    /**
     * Get the actual instance of `AchievementRewardClaimed`. If the actual instanct is not `AchievementRewardClaimed`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `AchievementRewardClaimed`
     * @throws ClassCastException if the instance is not `AchievementRewardClaimed`
     */
    public AchievementRewardClaimed getAchievementRewardClaimed() throws ClassCastException {
        return (AchievementRewardClaimed)super.getActualInstance();
    }

    /**
     * Get the actual instance of `AchievementRewardCreated`. If the actual instanct is not `AchievementRewardCreated`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `AchievementRewardCreated`
     * @throws ClassCastException if the instance is not `AchievementRewardCreated`
     */
    public AchievementRewardCreated getAchievementRewardCreated() throws ClassCastException {
        return (AchievementRewardCreated)super.getActualInstance();
    }

    /**
     * Get the actual instance of `AchievementRewardIssued`. If the actual instanct is not `AchievementRewardIssued`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `AchievementRewardIssued`
     * @throws ClassCastException if the instance is not `AchievementRewardIssued`
     */
    public AchievementRewardIssued getAchievementRewardIssued() throws ClassCastException {
        return (AchievementRewardIssued)super.getActualInstance();
    }

    /**
     * Get the actual instance of `AchievementTriggered`. If the actual instanct is not `AchievementTriggered`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `AchievementTriggered`
     * @throws ClassCastException if the instance is not `AchievementTriggered`
     */
    public AchievementTriggered getAchievementTriggered() throws ClassCastException {
        return (AchievementTriggered)super.getActualInstance();
    }

    /**
     * Get the actual instance of `CompetitionCancelled`. If the actual instanct is not `CompetitionCancelled`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `CompetitionCancelled`
     * @throws ClassCastException if the instance is not `CompetitionCancelled`
     */
    public CompetitionCancelled getCompetitionCancelled() throws ClassCastException {
        return (CompetitionCancelled)super.getActualInstance();
    }

    /**
     * Get the actual instance of `CompetitionCreated`. If the actual instanct is not `CompetitionCreated`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `CompetitionCreated`
     * @throws ClassCastException if the instance is not `CompetitionCreated`
     */
    public CompetitionCreated getCompetitionCreated() throws ClassCastException {
        return (CompetitionCreated)super.getActualInstance();
    }

    /**
     * Get the actual instance of `CompetitionFinished`. If the actual instanct is not `CompetitionFinished`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `CompetitionFinished`
     * @throws ClassCastException if the instance is not `CompetitionFinished`
     */
    public CompetitionFinished getCompetitionFinished() throws ClassCastException {
        return (CompetitionFinished)super.getActualInstance();
    }

    /**
     * Get the actual instance of `CompetitionRewardIssued`. If the actual instanct is not `CompetitionRewardIssued`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `CompetitionRewardIssued`
     * @throws ClassCastException if the instance is not `CompetitionRewardIssued`
     */
    public CompetitionRewardIssued getCompetitionRewardIssued() throws ClassCastException {
        return (CompetitionRewardIssued)super.getActualInstance();
    }

    /**
     * Get the actual instance of `CompetitionStarted`. If the actual instanct is not `CompetitionStarted`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `CompetitionStarted`
     * @throws ClassCastException if the instance is not `CompetitionStarted`
     */
    public CompetitionStarted getCompetitionStarted() throws ClassCastException {
        return (CompetitionStarted)super.getActualInstance();
    }

    /**
     * Get the actual instance of `ContestCancelled`. If the actual instanct is not `ContestCancelled`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `ContestCancelled`
     * @throws ClassCastException if the instance is not `ContestCancelled`
     */
    public ContestCancelled getContestCancelled() throws ClassCastException {
        return (ContestCancelled)super.getActualInstance();
    }

    /**
     * Get the actual instance of `ContestCreated`. If the actual instanct is not `ContestCreated`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `ContestCreated`
     * @throws ClassCastException if the instance is not `ContestCreated`
     */
    public ContestCreated getContestCreated() throws ClassCastException {
        return (ContestCreated)super.getActualInstance();
    }

    /**
     * Get the actual instance of `ContestFinalised`. If the actual instanct is not `ContestFinalised`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `ContestFinalised`
     * @throws ClassCastException if the instance is not `ContestFinalised`
     */
    public ContestFinalised getContestFinalised() throws ClassCastException {
        return (ContestFinalised)super.getActualInstance();
    }

    /**
     * Get the actual instance of `ContestFinished`. If the actual instanct is not `ContestFinished`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `ContestFinished`
     * @throws ClassCastException if the instance is not `ContestFinished`
     */
    public ContestFinished getContestFinished() throws ClassCastException {
        return (ContestFinished)super.getActualInstance();
    }

    /**
     * Get the actual instance of `ContestRewardClaimed`. If the actual instanct is not `ContestRewardClaimed`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `ContestRewardClaimed`
     * @throws ClassCastException if the instance is not `ContestRewardClaimed`
     */
    public ContestRewardClaimed getContestRewardClaimed() throws ClassCastException {
        return (ContestRewardClaimed)super.getActualInstance();
    }

    /**
     * Get the actual instance of `ContestRewardCreated`. If the actual instanct is not `ContestRewardCreated`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `ContestRewardCreated`
     * @throws ClassCastException if the instance is not `ContestRewardCreated`
     */
    public ContestRewardCreated getContestRewardCreated() throws ClassCastException {
        return (ContestRewardCreated)super.getActualInstance();
    }

    /**
     * Get the actual instance of `ContestRewardIssued`. If the actual instanct is not `ContestRewardIssued`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `ContestRewardIssued`
     * @throws ClassCastException if the instance is not `ContestRewardIssued`
     */
    public ContestRewardIssued getContestRewardIssued() throws ClassCastException {
        return (ContestRewardIssued)super.getActualInstance();
    }

    /**
     * Get the actual instance of `ContestStarted`. If the actual instanct is not `ContestStarted`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `ContestStarted`
     * @throws ClassCastException if the instance is not `ContestStarted`
     */
    public ContestStarted getContestStarted() throws ClassCastException {
        return (ContestStarted)super.getActualInstance();
    }

    /**
     * Get the actual instance of `NewMember`. If the actual instanct is not `NewMember`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `NewMember`
     * @throws ClassCastException if the instance is not `NewMember`
     */
    public NewMember getNewMember() throws ClassCastException {
        return (NewMember)super.getActualInstance();
    }

    /**
     * Get the actual instance of `NewProduct`. If the actual instanct is not `NewProduct`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `NewProduct`
     * @throws ClassCastException if the instance is not `NewProduct`
     */
    public NewProduct getNewProduct() throws ClassCastException {
        return (NewProduct)super.getActualInstance();
    }

}

